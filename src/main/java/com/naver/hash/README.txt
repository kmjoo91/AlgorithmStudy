1. 해시의 개념
해시(Hash)는 계산 과정을 거치면서 작아진 값.
입력 -> 분해/조립 -> 해시의 과정을 통해 해시를 구한다.
Ex) 1065 -> 분해/조립 -> 15 (1065의 해시 15를 구했다.)

해시는 어떤 과정을 거쳐 작아진 '값'을 의미하므로 해시값이라고도 한다.
또 책에 따라 해시 코드라고도 한다.
즉 해시 = 해시값 = 해시코드 이다.


앞으로는 관련 알고리즘을 다룰 텐데 그 전에 몇가지 용어 정리.
* 해시 함수
- 해시의 개념에서 해시를 구하는 과정이 입력 -> 분해/조립 -> 해시라고 했는데 이 과정을 해싱이라 칭한다.
해싱에서 분해/조립 단계를 해시 함수라고 한다.
즉 해시 함수는 분해 및 조립등의 연산을 통해 입력값을 해시로 만드는 함수이다.
해시 함수의 중요한 점은 구해진 해시가 다른 해시와 구별되는 고유한 값이어야 한다는 점이다.
Ex) 101의 해시와 202의 해시는 다르다.
이 점은 해시함수의 경쟁력이라고 볼 수 있다.

*해시 검색
- 검색 키에 대한 해시를 계산하여 검색하는 방법.
Ex) 학번으로 학생 자료를 찾으려는 경우 학번이 검색 키가 된다.
즉 학번이 입력값이 되고 해시 함수를 거쳐 해시가 나오게된다.
여기서 해시는 검색하려는 자료의 주소가 된다고 했을때 해당 자료가 저장된 위치로 곧장 접근이 가능하다.

*해시 테이블
-해시 함수로 계산한 주소에 따라 자료를 저장하는 자료 구조
해시 테이블은 일반적으로 주소를 통해 바로 접근할 수 있는 배열을 선호한다.
해시 테이블은 N개의 버킷(Bucket)으로 이루어져 있습니다.


*버킷
- 해시테이블에서 자료를 저장하는 단위로 하나의 고유한 해시에 대응하여 실제 자료가 저장되는 곳.


*해싱
- 해시뒤에 ing가 붙은 단어로 '해시를 만든다'는 뜻입니다.
해싱의 경우 해시를 구하는 과정을 의미하고 해시는 '값'자체를 의미합니다.



2.해시 검색
해시검색은 해시를 이용하여 검색을 하는것으로 다른 검색알고리즘과 비교해 속도가 월등히 빠르다는 장점이 있다.





2.1 해시검색의 기본 개념
해시검색에서는 해시키라는 개념이 있는데 해시키는 내가 찾고자 하는 자료를 가리키는 값을 말한다.
학생자료를 찾는 예시를 들어서 설명.
검색키는 학번이 되고 계산된 해시는 검색하려는 자료의 위치가 된다.
예를들어 학번이 2016102라는 학생이 해시함수를 거쳤을 때 2라는 해시값을 가진다고 했을때,
2는 2016102학번을 가진 학생의 자료가 저장된 주소가 된다.
따라서 해당 자료가 저장된 위치로 곧장 접근할 수 있다.
여기서 헤시테이블은 학생자료가 저장된 테이블이다.
2016102학생의 학생자료는 2번 버킷에 저장되어있다.
참고로 버킷에는 한개의 자료만 저장할수도 슬롯이라는걸 두고 여러개의 자료를 저장할 수도 있다.





2.2 해시검색의 과정
2.2.1 자료 추가
해시검색을 하기 위해선 자료가 해시테이블에 미리 저장이 되어있어야 한다.
자료 추가의 경우 아래와 같은 3단계를 거친다.
주소계산 -> 해시테이블 확인 -> 자료저장.

*주소계산
- 주소 계산의 경우 전달받은 자료의 '검색키'로 자료를 저장할 버킷의 주소를 계산하는 단계다.
이 과정을 거치는 이유는 위에서 예를 든 학번을 예로들면 0000000 ~ 9999999까지 모두 10^7개만큼 값이 생길 수 있다.
반면 실제 해시 테이블의 경우 어떤 구조를 가지냐에따라 다르겠지만 00 ~ 99까지의 버켓을 둔다면 10^2개만큼만 저장할 수 있다.
값의 범위가 대략 10만배 작아진다.
이렇게 범위가 줄어드는 이유는 해시함수를 거치며 입력값이 작아지기 때문이다.
해시함수에서 값을 줄이는 방법은 뒤쪽에서 설명.

*해시테이블 확인
해시테이블 확인단계의경우 주소계산단계에서 계산된 주소(해시)를 가지고 해시 테이블을 확인한다.
자료가 저장될 주소를 알고도 확인을 하는 이유는 계산된 주소에 이미 다른 자료가 저장되어있는 경우때문이다.
물론 자료가 저장되어있지않으면 바로 저장을 한다.
하지만 이미 자료가 있어서 자료를 저장하지 못하는 경우가 발생할 수 있다.
이 경우를 충돌(Collision)이라고 한다.
Ex)
| 검색키 |해시|
| 2016102|   2|
| 2016202|   2|
충돌이 발생하면 자료를 저장할 수 있는 새로운 주소를 다시 계산해야한다.
해시 충돌의 경우 상당히 난처한 상황으로 이에 대처하기위한 다양한 방법이 제시되어있다.
이런 해시 충돌 방안의 경우 뒤쪽에서 설명.

*자료저장
실제 해시테이블에 자료를 저장하는 단계.
2단계에서 확인 후 빈 주소라면 자료를 저장하고 충돌이 발생했다면 다른 주소를 찾아서 저장한다.





2.2.2 자료 검색
자료 검색의 경우 아래와 같은 2단계를 거친다.
주소계산 -> 해시테이블 확인

*주소계산
- 전달받은 '검색키'값으로 버킷의 주소를 계산한다. 즉 해시함수를 이용하여 입력값에 대한 해시를 구한다.

*해시테이블 확인
- 주소 계산에서 계산한 해시를 통해 해시테이블에 정말 자료가 저장되어있는지 확인한다.





3.해시함수
위에서 얘기했듯이 해시의 핵심은 바로 해시함수다.
어떤 해시함수를 사용하느냐에 따라 해시 검색의 성능이 결정되기 때문이다.
구체적인 내용으로 들어가기전에 해시함수의 조건을 살펴보자.

*충돌발생빈도
- 충돌이 많이 발생한다는 것은 비어있는 주소가 있음에도 비어있지 않은 주소에 반복해서 저장할 가능성이 크다는 것으로 충돌발생빈도는 낮을수록 좋다.

*해시테이블사용률(분포율)
- 해시 테이블을 고르게 분포시킬 수 있는 해시 함수가 저장 공간 활용 효율면에서 좋다.

*해시함수계산속도
- 해시검색에 걸리는 시간을 감소시키기 때문에 효율면에서 좋다.





3.1 나머지 함수
해시함수에서 가장 쉽게 사용할 수 있는 함수중 하나이다.
나머지함수는 검색키 k를 해시테이블의 크기 M으로 나눈 나머지를 해시로 사용한다.
Ex)
| k | M |hash|
|125|100|  25|
| 15|  7|   1|

다만 나머지 함수를 해시 함수로 사용할 경우 테이블 크기 M이 소수일 수록 충돌 발생 빈도가 낮아진다.
충돌발생빈도가 낮다는 뜻은 해시테이블사용률 또한 높아진다는 뜻이다.
따라서 나머지 함수를 사용할 경우 될수있으면 M은 소수로 하는것이 좋다.





3.2 접기 함수
접기함수(혹은 접지합수)는 검색키를 먼저 분해하고 분해된 부분들을 조합하여 해시를 만드는 방법을 말한다.
보통 검색키의 크기가 해시테이블의 크기보다 큰 경우에 많이 사용한다.
접기 함수의 경우 세부 구현 방법에 따라 다양한 적용이 가능하다. 여기서는 대표적인 이동 접기 함수, 경계 접기 함수에 대해서 설명하겠다.





3.2.1 이동 접기 함수
이동 접기 함수는 분해된 부분들을 이동시킨 다음에 각 부분을 조합하는 접기 방법을 말한다.

Ex) 검색키 1234512345에 대해서 이동 접기 함수로 해시를 구하는 과정.
검색키 - 1234512345, 10자리
해시테이블크기 - 99, 3자리

*분해 단계
접기함수에서는 가장 먼저 검색 키를 분해한다. 보통 검색키의 크기가 해시 테이블의 크기보다 크기때문에 해시 테이블의 크기(자릿수)로 검색키를 분해한다.
123,451,234,5 와 같이 분해한다.
10자리의 검색키가 해시 테이블의 크기인 3에 따라 모두 분해됐다.

*이동 및 더하기 단계
앞서 분해 단계에서 분해한 4개의 키를 오른쪽 맞춤으로 이동한다.
여기서 오른쪽 맞춤이란 결국 자릿수가 작으면 일의자리 쪽으로 맞춘다는 뜻이다.
Ex)
123
451
234
  5
오른쪽 맞춤을 한 뒤 전부 더해준다.
123 + 451 + 234 + 5 = 813
1234512345의 검색키와 해시테이블의 크기가 999일 경우 이동 접기 함수를 이용하면 해시가 813이 나온다.
이동 접기 결과가 1234와 같이 해시테이블크기보다 클 경우 짤라내고 234만 해시로 취한다.




3.2.2 경계 접기 함수
경계 접기 함수는 이동 접기 함수와 마찬가지로 '접기'를 기본적인 계산방법으로 사용하고있다.
다만 이동하기 부분에서 차이점이있고 분해 및 더하기는 같다.

*분해하기
분해는 이동 접기 함수와 마찬가지로 입력값 1234512345, M 999일 때
123,451,234,5로 나뉘어 진다.
이 분해된 4부분중 먼저 기준이 되는 부분은 가장 오른쪽에 있는 부분이다. (여기선 5)
기준부분은 경계 부분이 아니게 되고 그 다음부분인 234가 경계부분이된다.
이때 경계부분은 서로 인접할 수 없어서 451의 경우 경계부분이 아니게 된다.
따라서 그 다음 부분인 123이 경계부분이 된다.
즉 경계부분은 123, 234부분이 되며 경계가 아닌부분이 451,5가 된다.

*이동하기
이 부분이 이동 접기 함수와 다른부분으로 경계부분은 뒤집기 처리를 해준다.
즉 321,451,432,5로 분해된 4부분이 변하게 된다.
이렇게 뒤집는 이유는 기존 숫자의 자릿수를 변경함으로써 충돌 확률을 낮추기 위해서이다.

*더하기
321 + +451 + 432 + 5 = 1209로 초과 자릿수는 버려지므로 해시는 209가 된다.




3.3 중간 제곱 함수
중간 제곱 함수는 검색 키의 일부분에서 해시를 채취하는 방법이다.
특이점으로는 원래 검색키에서 값을 추출하는 것이 아니라 먼저 검색키의 제곱값을 구하고 그 제곱된 값중에서 중간 부분을 잘라내어 해시를 구한다.

Ex)검색키 9415, 해시테이블의 크기 M 9999
9415 * 9415 = 89321401
M이 4자리이므로 가운데 4자리를 꺼내 해시로 사용한다.
즉 해시는 3214가 된다.



3.4 숫자 분석 기반의 해시 함수
마지막으로 살펴볼 해시 함수는 숫자 분석 기반의 해시함수이다.
여기서 '숫자 분석 기반'의 뜻은 검색키가 어떠한 특징이 있는지 검색키의 특성을 알아낸다는 뜻이다.

숫자로 이루어진 검색키가 있다고 가정했을때 숫자 분석기반인 해시함수에서는 먼저 각 자릿수의 분포를 분석한다.
Ex) '학번'으로 해시를 구하는 경우.
검색키 : 2016-1025 (첫네자리인 2016은 입학년도, 그다음 두자리인 10은 학과번호, 그다음 두자리인 25는 같은 학과내의 학생 고유 번호)
학번의 처음 4자리는 입학년도이기때문에 그해에 입학한 학생들은 모두 같은값을 가진다.
그러나 그 뒤의 4자리는 학과 및 학생 고유번호이기때문에 비교적 고르게 분포되어있다.
입학년도의 경우 많은 수의 학생이 가지고있으므로 해시함수의 입력값에 부적합하고 뒤의 4자리가 입력값에 적합하다.
따라서 이 경우 1025가 해시함수의 입력값으로 적합하다.





3.5 이외의 해시 함수들
진법 변환 함수, 비트 추출 함수, 가상 난수 기법등이 존재한다.
또한 현재까지의 예시들에선 입력값이 정수일 경우만 가정해서 진행했다.
하지만 입력값이 문자열인경우는 어떻게 해야할까?
입력값이 문자열인경우 문자열을 구성하는 각 문자를 아스키코드로 변환시킨다. 그 뒤 모든 문자열을 사용할지 혹은 처음문자만 사용할지등을 정해서 입력값으로 정해주면된다.




4. 충돌 해결 방법
충돌이 발생했을 때 두가지 방법이 있다.

*개방주소법
- 충돌이 일어난 키 값을 비어 있는 다른 주소를 찾아 저장

*체이닝
- 여러 개의 항목을 저장할 수 있도록 해시 테이블의 구조를 변경




4.1 개방 주소법
개방 주소법은 어떻게 '다음주소'를 계산할지에 따라서 선형 조사법, 제곱 조사법, 이중 해싱등의 기법으로 나뉜다.





4.1.1 선형 조사법
충돌이 발생한 경우 일정한 상수만큼 증가시켜서 다시 조사하는 방법.
Ex) 해시테이블의 주소 h에서 충돌이 발생할 경우 주소를 1만큼씩 증가시켜 다시 조사.
즉, 선형주소법에서는 발생한 주소에서 일정한 상수를 더해가면서 선형적으로 주소를 찾아가는 방식이다.

Ex)try_count를 더하는 방법( 상수가 1 )
h(k) = (k + try_count) mod M
h(k) ->  충돌 -> h(k+1) -> 충돌 -> h(k+2) -> ......
물론 이방법의 경우 해시 테이블의 모든 주소가 차있을 때 실패하게된다.

또한 선형조사법의 단점으로는 한번 충돌이 일어나게되면 충돌이 발생한 주소 주위로 자료가 뭉치는 군집화 현상이 발생한다.
Ex) M = 5, 해시함수 = 나머지함수, 저장되는 검색 키 값 = {1, 3, 8, 13}, 증가되는 상수 = 1
h(1) = 1, h(3) = 3, h(8) = 3 -> 4, h(13) = 3 -> 4 -> 5

이 예시를 통해 선형 조사법의 경우 충돌과 군집화 현상이 잘 일어나는것을 확인했다.





4.1.2 제곱조사법
충돌이 발생할 경우 주소를 조사 횟수의 제곱만큼 증가시켜 다시 조사하는 방법.
1차 충돌에는 1^2, 2차 충돌에는 2^2, 3차충돌에는 3^2, ......, n차 충돌에는 n^2
식으로 표현할 경우 아래와 같다.
h(k) = (k + try_count^2) mod M

제곱조사법의 단점으로는 선형 조사법에 비해 군집화가 덜 발생하지만 아직도 군집화가 발생할 가능성이 높은편이다.
또한 해시 테이블의 모든 주소를 조사하려면 해시 테이블의 크기가 반드시 소수여야한다는 제약사항이 있다.

Ex) M = 5, 해시함수 = 나머지함수, 저장되는 검색 키 값 = {1, 3, 8, 13}, 증가되는 상수 = 1
h(1) = 1, h(3) = 3, h(8) = 3 -> 4, h(13) = 3 -> 4 -> -> 3 -> 2





4.1.3 이중 해시
충돌이 발생하면 원래의 해시함수와는 다른 추가적인 해시 함수를 이용해 다시 조사하는 방법.
어떤 해시함수를 사용할지에 따라서 다양한 방법이 있다.
가장 간단한 방법으로는 다음과 같은 조사 간경을 이용하는 방법이 있다.
Ex)조사간격(증가되는 상수) = M - (k mod M)
M = 5, 해시함수 = 나머지함수, 저장되는 검색 키 값 = {1, 3, 8, 13}, 증가되는 상수 = 1
h(1) = 1, h(3) = 3,
h(8) = 3
=> 조사간격 = 5 - (8 mod 5) = 2
=> (3 + 2) mod 5
= 0,
h(13) = 3
=> 조사간격 5 - (3 mod 5) = 2
=> (3 + 2) mod 5
=> (0 + 2) mod 5
= 2





